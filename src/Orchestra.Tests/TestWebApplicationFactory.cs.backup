using Microsoft.AspNetCore.Hosting;
using Microsoft.AspNetCore.Mvc.Testing;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Hosting;
using Orchestra.Core.Services;
using Orchestra.Tests.Integration.Mocks;
using System.Collections.Generic;

namespace Orchestra.Tests;

/// <summary>
/// Custom WebApplicationFactory that provides test isolation by using unique databases
/// for each test run. This prevents test interference through shared SQLite storage.
/// Separates EF Core and Hangfire databases to avoid SQLiteStorage disposal conflicts.
/// </summary>
/// <typeparam name="TStartup">The startup class type</typeparam>
public class TestWebApplicationFactory<TStartup> : WebApplicationFactory<TStartup>
    where TStartup : class
{
    private readonly string _testInstanceId;
    private readonly string _hangfireDbName;
    private readonly string _efCoreDbName;

    public TestWebApplicationFactory()
    {
        // Create unique database names for this test factory instance
        // Use DateTime.Now.Ticks to ensure uniqueness even across rapid test execution
        _testInstanceId = $"{Guid.NewGuid().ToString("N")}_{DateTime.Now.Ticks}";
        _hangfireDbName = $"test-orchestra-hangfire-{_testInstanceId}.db";
        _efCoreDbName = $"test-orchestra-efcore-{_testInstanceId}.db";
    }

    protected override void ConfigureWebHost(IWebHostBuilder builder)
    {
        builder.ConfigureAppConfiguration((context, config) =>
        {
            // Override database connection strings with test-specific databases
            // This separates EF Core and Hangfire databases to prevent disposal conflicts
            var testConfig = new Dictionary<string, string?>
            {
                ["ASPNETCORE_ENVIRONMENT"] = "Testing",  // Force testing environment
                ["HANGFIRE_CONNECTION"] = "InMemory",    // Signal for in-memory storage
                ["EFCORE_CONNECTION"] = _efCoreDbName
            };

            config.AddInMemoryCollection(testConfig);
        });

        builder.ConfigureServices(services =>
        {
            // Remove background services that can interfere with tests
            var backgroundServiceTypes = new[]
            {
                typeof(Orchestra.Core.Services.AgentHealthCheckService),
                typeof(Orchestra.Core.Services.AgentDiscoveryService),
                typeof(Orchestra.Core.Services.BackgroundTaskAssignmentService),
                typeof(Orchestra.Core.AgentScheduler)
            };

            foreach (var serviceType in backgroundServiceTypes)
            {
                var serviceDescriptor = services.FirstOrDefault(d =>
                    d.ServiceType == typeof(IHostedService) &&
                    d.ImplementationType == serviceType);
                if (serviceDescriptor != null)
                {
                    services.Remove(serviceDescriptor);
                }
            }

            // Replace real IAgentExecutor with MockAgentExecutor for tests
            var agentExecutorDescriptor = services.FirstOrDefault(d => d.ServiceType == typeof(IAgentExecutor));
            if (agentExecutorDescriptor != null)
            {
                services.Remove(agentExecutorDescriptor);
            }

            // Replace IAgentStateStore with TestAgentStateStore for test isolation
            var agentStateStoreDescriptor = services.FirstOrDefault(d => d.ServiceType == typeof(Orchestra.Core.Abstractions.IAgentStateStore));
            if (agentStateStoreDescriptor != null)
            {
                services.Remove(agentStateStoreDescriptor);
            }

            // Register mock services as scoped for better test isolation
            // Using scoped services helps prevent state leakage between tests
            services.AddScoped<MockAgentExecutor>();
            services.AddScoped<IAgentExecutor>(provider => provider.GetRequiredService<MockAgentExecutor>());
            services.AddScoped<TestAgentRegistry>(provider =>
                new TestAgentRegistry(provider.GetRequiredService<MockAgentExecutor>()));

            // Register TestAgentStateStore that integrates with MockAgentExecutor
            services.AddScoped<Orchestra.Core.Abstractions.IAgentStateStore, TestAgentStateStore>(provider =>
                new TestAgentStateStore(provider.GetRequiredService<MockAgentExecutor>()));

            // Replace HangfireOrchestrator with test configuration (disable auto-agent creation)
            var hangfireOrchestratorDescriptor = services.FirstOrDefault(d => d.ServiceType == typeof(Orchestra.API.Services.HangfireOrchestrator));
            if (hangfireOrchestratorDescriptor != null)
            {
                services.Remove(hangfireOrchestratorDescriptor);
            }

            services.AddScoped<Orchestra.API.Services.HangfireOrchestrator>(provider =>
            {
                var jobClient = provider.GetRequiredService<Hangfire.IBackgroundJobClient>();
                var entityOrchestrator = provider.GetRequiredService<Orchestra.API.Services.EntityFrameworkOrchestrator>();
                var legacyOrchestrator = provider.GetRequiredService<Orchestra.Core.SimpleOrchestrator>();
                var logger = provider.GetRequiredService<Microsoft.Extensions.Logging.ILogger<Orchestra.API.Services.HangfireOrchestrator>>();
                var taskRepository = provider.GetRequiredService<Orchestra.API.Services.TaskRepository>();
                var agentRepository = provider.GetRequiredService<Orchestra.API.Services.AgentRepository>();

                // Disable auto-agent creation for tests to allow proper failure testing
                return new Orchestra.API.Services.HangfireOrchestrator(jobClient, entityOrchestrator, legacyOrchestrator, logger, taskRepository, agentRepository, autoCreateAgents: false);
            });
        });

        builder.UseEnvironment("Testing");
    }

    protected override void Dispose(bool disposing)
    {
        if (disposing)
        {
            // Clean up both test database files
            try
            {
                if (File.Exists(_hangfireDbName))
                {
                    File.Delete(_hangfireDbName);
                }
                
                if (File.Exists(_efCoreDbName))
                {
                    File.Delete(_efCoreDbName);
                }
            }
            catch
            {
                // Ignore cleanup errors - database files might be locked during disposal
                // This is expected in some test scenarios and doesn't affect test isolation
            }
        }

        base.Dispose(disposing);
    }
}
