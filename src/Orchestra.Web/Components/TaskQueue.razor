@using Orchestra.Web.Models
@using Orchestra.Web.Services
@using Orchestra.Web.Components.Base
@using Orchestra.Core.Models
@using TaskPriority = Orchestra.Core.Models.TaskPriority
@using TaskRequest = Orchestra.Core.Models.TaskRequest
@inject OrchestratorService OrchestratorService
@inherits AutoRefreshComponent

<div class="task-queue">
    <div class="queue-header">
        <h3>Task Queue @(_showAllTasks ? "(All Repositories)" : "")</h3>
        <div class="queue-controls">
            <button class="refresh-button" @onclick="RefreshQueue" disabled="@_isLoading">
                @if (_isLoading)
                {
                    <span class="spinner"></span>
                }
                else
                {
                    <span>üîÑ</span>
                }
                Refresh
            </button>
            <div class="auto-refresh-toggle">
                <input type="checkbox" id="queue-auto-refresh" @bind="AutoRefresh" />
                <label for="queue-auto-refresh">Auto-refresh</label>
            </div>
        </div>
    </div>

    <div class="queue-content">
        @if (string.IsNullOrEmpty(SelectedRepository))
        {
            <div class="no-selection">
                <div class="selection-help">
                    <h4>üìã Task Queue Help</h4>
                    <p><strong>How to view tasks:</strong></p>
                    <ol>
                        <li>Go to <strong>Agent Status</strong> tab</li>
                        <li>Click on any agent in the list</li>
                        <li>Their repository tasks will appear here</li>
                    </ol>
                    <p><em>Or select a repository from the sidebar to see all its tasks</em></p>
                </div>
                <div class="global-queue-option">
                    <button class="btn btn-secondary" @onclick="ShowAllTasks">
                        üåê Show All Tasks (All Repositories)
                    </button>
                </div>
            </div>
        }
        else if (_isLoading && (_tasks == null || !_tasks.Any()))
        {
            <div class="loading">
                <div class="spinner"></div>
                <p>Loading tasks...</p>
            </div>
        }
        else if (_tasks != null && _tasks.Any())
        {
            <div class="task-stats">
                <div class="stat">
                    <span class="stat-label">Total:</span>
                    <span class="stat-value">@_tasks.Count</span>
                </div>
                <div class="stat">
                    <span class="stat-label">Pending:</span>
                    <span class="stat-value queued">@_tasks.Count(t => t.Status == Orchestra.Core.Models.TaskStatus.Pending)</span>
                </div>
                <div class="stat">
                    <span class="stat-label">In Progress:</span>
                    <span class="stat-value inprogress">@_tasks.Count(t => t.Status == Orchestra.Core.Models.TaskStatus.InProgress)</span>
                </div>
                <div class="stat">
                    <span class="stat-label">Completed:</span>
                    <span class="stat-value completed">@_tasks.Count(t => t.Status == Orchestra.Core.Models.TaskStatus.Completed)</span>
                </div>
                <div class="stat">
                    <span class="stat-label">Failed:</span>
                    <span class="stat-value failed">@_tasks.Count(t => t.Status == Orchestra.Core.Models.TaskStatus.Failed)</span>
                </div>
            </div>

            <div class="task-list">
                @foreach (var task in _tasks.Take(ComponentConstants.Tasks.DisplayLimit))
                {
                    <div class="task-item @GetPriorityClass(task.Priority)">
                        <div class="task-header">
                            <div class="task-priority">
                                @GetPriorityIcon(task.Priority)
                                <span class="priority-text">@task.Priority</span>
                            </div>
                            <div class="task-status @GetStatusClass(task.Status)">
                                <span class="status-icon">@GetStatusIcon(task.Status)</span>
                                <span class="status-text">@task.Status</span>
                                @if (task.Status == Orchestra.Core.Models.TaskStatus.InProgress && task.StartedAt.HasValue)
                                {
                                    <span class="status-duration">@GetTaskDuration(task.StartedAt.Value)</span>
                                }
                            </div>
                            <div class="task-time">@GetTimeAgo(task.CreatedAt)</div>
                        </div>

                        @if (task.Status == Orchestra.Core.Models.TaskStatus.InProgress)
                        {
                            <div class="task-progress">
                                <div class="progress-bar">
                                    <div class="progress-fill indeterminate"></div>
                                </div>
                            </div>
                        }

                        <div class="task-command" title="@task.Command">
                            @GetShortCommand(task.Command)
                        </div>

                        @if (!string.IsNullOrEmpty(task.Result) && task.Status is Orchestra.Core.Models.TaskStatus.Completed or Orchestra.Core.Models.TaskStatus.Failed)
                        {
                            <div class="task-result @(task.Status == Orchestra.Core.Models.TaskStatus.Failed ? "error" : "success")"
                                 title="@task.Result">
                                <span class="result-icon">@(task.Status == Orchestra.Core.Models.TaskStatus.Failed ? "‚ùå" : "‚úÖ")</span>
                                <span class="result-text">@GetShortResult(task.Result)</span>
                            </div>
                        }
                        <div class="task-details">
                            <div class="task-id">ID: @task.Id[..8]...</div>
                            @if (_showAllTasks && !string.IsNullOrEmpty(task.RepositoryPath))
                            {
                                <div class="task-repository" title="@task.RepositoryPath">
                                    üìÅ @GetRepositoryDisplayName(task.RepositoryPath)
                                </div>
                            }
                            @if (!string.IsNullOrEmpty(task.AgentId))
                            {
                                <div class="assigned-agent" title="@task.AgentId">
                                    Assigned to: @GetAgentDisplayName(task.AgentId)
                                </div>
                            }
                            else
                            {
                                <div class="unassigned">Unassigned</div>
                            }
                        </div>
                    </div>
                }

                @if (_tasks.Count > ComponentConstants.Tasks.DisplayLimit)
                {
                    <div class="more-tasks">
                        <p>...and @(_tasks.Count - ComponentConstants.Tasks.DisplayLimit) more tasks</p>
                    </div>
                }
            </div>
        }
        else
        {
            <div class="no-tasks">
                <p>No tasks in queue for this repository</p>
            </div>
        }
    </div>

    @if (!string.IsNullOrEmpty(_errorMessage))
    {
        <div class="error-message">
            <strong>Error:</strong> @_errorMessage
        </div>
    }
</div>

@code {
    [Parameter] public string? SelectedRepository { get; set; }
    [Parameter] public string? RepositoryPath { get; set; }

    private List<TaskRequest> _tasks = new();
    private bool _isLoading = false;
    private string? _errorMessage;
    private string? _lastRepository;
    private Dictionary<string, AgentInfo> _allAgents = new();
    private List<string> _taskLog = new();
    private bool _showAllTasks = false;

    protected override async Task OnParametersSetAsync()
    {
        if (SelectedRepository != _lastRepository)
        {
            _lastRepository = SelectedRepository;
            await LoadTasks();
        }
    }

    protected override async Task OnInitializedAsync()
    {
        // Set 3-second refresh interval for task queue (faster updates)
        RefreshInterval = TimeSpan.FromSeconds(3);
        await base.OnInitializedAsync();
    }

    protected override async Task RefreshDataAsync()
    {
        await LoadTasks();
    }

    private async Task LoadTasks()
    {
        // Fast-return pattern for early validation
        if (!_showAllTasks && (string.IsNullOrEmpty(SelectedRepository) || string.IsNullOrEmpty(RepositoryPath)))
        {
            _tasks = new List<TaskRequest>();
            return;
        }

        SetLoadingState(true);

        try
        {
            var state = await OrchestratorService.GetStateAsync();
            ProcessTasksFromState(state);
        }
        catch (Exception ex)
        {
            HandleLoadError(ex);
        }
        finally
        {
            SetLoadingState(false);
        }
    }

    private void ProcessTasksFromState(OrchestratorState? state)
    {
        if (state?.TaskQueue == null)
        {
            _tasks = new List<TaskRequest>();
            return;
        }

        var previousTaskCount = _tasks.Count;
        var previousTaskIds = _tasks.Select(t => t.Id).ToHashSet();

        _tasks = state.TaskQueue
            .Where(t => _showAllTasks || t.RepositoryPath == RepositoryPath)
            .OrderBy(t => GetPriorityValue(t.Priority))
            .ThenBy(t => t.CreatedAt)
            .ToList();

        // Store all agents for name lookup
        if (state.Agents != null)
        {
            _allAgents = state.Agents;
        }

        LogTaskChanges(previousTaskCount, previousTaskIds);
    }

    private void HandleLoadError(Exception ex)
    {
        _errorMessage = ex.Message;
        _tasks = new List<TaskRequest>();
        LogMessage($"ERROR loading tasks: {ex.Message}");
    }

    private void SetLoadingState(bool isLoading)
    {
        _isLoading = isLoading;
        if (isLoading)
        {
            _errorMessage = null;
        }
        StateHasChanged();
    }

    private void LogTaskChanges(int previousTaskCount, HashSet<string> previousTaskIds)
    {
        var currentTaskIds = _tasks.Select(t => t.Id).ToHashSet();
        var newTasks = _tasks.Where(t => !previousTaskIds.Contains(t.Id)).ToList();
        var removedTaskIds = previousTaskIds.Except(currentTaskIds).ToList();

        foreach (var task in newTasks)
        {
            var agentName = GetAgentDisplayName(task.AgentId);
            LogMessage($"NEW TASK: {task.Command[..Math.Min(ComponentConstants.Tasks.CommandLogLength, task.Command.Length)]}... ‚Üí {agentName} (Priority: {task.Priority})");
        }

        foreach (var taskId in removedTaskIds)
        {
            LogMessage($"REMOVED TASK: {taskId[..8]}... (task completed or disappeared)");
        }

        if (_tasks.Count != previousTaskCount)
        {
            LogMessage($"Task count changed: {previousTaskCount} ‚Üí {_tasks.Count}");
        }
    }

    private async Task RefreshQueue()
    {
        await ManualRefreshAsync();
    }

    private static int GetPriorityValue(TaskPriority priority)
    {
        switch (priority)
        {
            case TaskPriority.Critical:
            {
                return 1;
            }
            case TaskPriority.High:
            {
                return 2;
            }
            case TaskPriority.Normal:
            {
                return 3;
            }
            case TaskPriority.Low:
            {
                return 4;
            }
            default:
            {
                return 5;
            }
        }
    }

    private static string GetPriorityClass(TaskPriority priority)
    {
        return priority.ToString().ToLower();
    }

    private static string GetPriorityIcon(TaskPriority priority)
    {
        switch (priority)
        {
            case TaskPriority.Critical:
            {
                return "üö®";
            }
            case TaskPriority.High:
            {
                return "üî¥";
            }
            case TaskPriority.Normal:
            {
                return "üü°";
            }
            case TaskPriority.Low:
            {
                return "üü¢";
            }
            default:
            {
                return "‚ùì";
            }
        }
    }

    private static string GetShortCommand(string command)
    {
        const int maxLength = 80;
        if (command.Length <= maxLength)
        {
            return command;
        }

        return command[..maxLength] + "...";
    }

    private static string GetStatusClass(Orchestra.Core.Models.TaskStatus status)
    {
        return $"status-{status.ToString().ToLower()}";
    }

    private static string GetStatusIcon(Orchestra.Core.Models.TaskStatus status)
    {
        return status switch
        {
            Orchestra.Core.Models.TaskStatus.Pending => "‚è≥",
            Orchestra.Core.Models.TaskStatus.Assigned => "üìã",
            Orchestra.Core.Models.TaskStatus.InProgress => "‚ö°",
            Orchestra.Core.Models.TaskStatus.Completed => "‚úÖ",
            Orchestra.Core.Models.TaskStatus.Failed => "‚ùå",
            Orchestra.Core.Models.TaskStatus.Cancelled => "üö´",
            _ => "‚ùì"
        };
    }

    private static string GetTaskDuration(DateTime startTime)
    {
        var duration = DateTime.Now - startTime;

        if (duration.TotalMinutes < 1)
        {
            return $"{(int)duration.TotalSeconds}s";
        }

        if (duration.TotalHours < 1)
        {
            return $"{(int)duration.TotalMinutes}m {duration.Seconds}s";
        }

        return $"{(int)duration.TotalHours}h {duration.Minutes}m";
    }

    private static string GetShortResult(string result)
    {
        const int maxLength = 50;
        if (result.Length <= maxLength)
        {
            return result;
        }

        return result[..maxLength] + "...";
    }

    private static string GetTimeAgo(DateTime createdAt)
    {
        var timeSpan = DateTime.Now - createdAt;

        if (timeSpan.TotalMinutes < 1)
        {
            return "Just now";
        }

        if (timeSpan.TotalMinutes < 60)
        {
            return $"{(int)timeSpan.TotalMinutes}m ago";
        }

        if (timeSpan.TotalHours < 24)
        {
            return $"{(int)timeSpan.TotalHours}h ago";
        }

        return $"{(int)timeSpan.TotalDays}d ago";
    }

    private string GetAgentDisplayName(string? agentId)
    {
        if (string.IsNullOrEmpty(agentId))
        {
            return "Unassigned";
        }

        if (_allAgents.TryGetValue(agentId, out var agent))
        {
            return $"{agent.Name} ({agent.Type})";
        }

        // Fallback to showing a shortened ID if agent not found
        return $"Agent {agentId[..Math.Min(8, agentId.Length)]}...";
    }

    private void LogMessage(string message)
    {
        var timestamp = DateTime.Now.ToString("HH:mm:ss");
        var logEntry = $"[{timestamp}] {message}";
        _taskLog.Insert(0, logEntry);

        // Keep only last log entries
        if (_taskLog.Count > ComponentConstants.Tasks.LogEntryLimit)
        {
            _taskLog = _taskLog.Take(ComponentConstants.Tasks.LogEntryLimit).ToList();
        }

        // Log to browser console for debugging
        Console.WriteLine($"TaskQueue: {logEntry}");
    }

    private async Task ShowAllTasks()
    {
        _showAllTasks = true;
        await LoadTasks();
        StateHasChanged();
    }

    private static string GetRepositoryDisplayName(string repositoryPath)
    {
        if (string.IsNullOrEmpty(repositoryPath))
        {
            return "Unknown";
        }

        // Extract just the folder name from the path
        var directoryName = Path.GetFileName(repositoryPath.TrimEnd(Path.DirectorySeparatorChar, Path.AltDirectorySeparatorChar));
        return string.IsNullOrEmpty(directoryName) ? repositoryPath : directoryName;
    }

}