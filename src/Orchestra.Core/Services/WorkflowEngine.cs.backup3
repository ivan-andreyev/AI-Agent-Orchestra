using Microsoft.Extensions.Logging;
using Orchestra.Core.Models.Workflow;

namespace Orchestra.Core.Services;

/// <summary>
/// Основная реализация движка выполнения workflow
/// </summary>
public class WorkflowEngine : IWorkflowEngine
{
    private readonly ILogger<WorkflowEngine> _logger;
    private readonly ILoopExecutor _loopExecutor;
    private readonly Dictionary<string, WorkflowExecutionResult> _executionResults;

    /// <summary>
    /// Инициализирует новый экземпляр WorkflowEngine
    /// </summary>
    /// <param name="logger">Логгер для записи событий выполнения</param>
    /// <param name="loopExecutor">Исполнитель циклов для обработки Loop шагов</param>
    public WorkflowEngine(ILogger<WorkflowEngine> logger, ILoopExecutor loopExecutor)
    {
        _logger = logger ?? throw new ArgumentNullException(nameof(logger));
        _loopExecutor = loopExecutor ?? throw new ArgumentNullException(nameof(loopExecutor));
        _executionResults = new Dictionary<string, WorkflowExecutionResult>();
    }

    /// <summary>
    /// Выполняет workflow асинхронно с заданным контекстом
    /// </summary>
    /// <param name="workflow">Определение workflow для выполнения</param>
    /// <param name="context">Контекст выполнения с переменными и состоянием</param>
    /// <returns>Результат выполнения workflow</returns>
    public async Task<WorkflowExecutionResult> ExecuteAsync(WorkflowDefinition workflow, WorkflowContext context)
    {
        if (workflow == null)
        {
            throw new ArgumentNullException(nameof(workflow));
        }

        if (context == null)
        {
            throw new ArgumentNullException(nameof(context));
        }

        _logger.LogInformation("Начало выполнения workflow {WorkflowId} с execution ID {ExecutionId}",
            workflow.Id, context.ExecutionId);

        // Валидация workflow перед выполнением (вне основного try-catch для корректного выброса исключений)
        var isValid = await ValidateWorkflowAsync(workflow);
        Console.WriteLine($"DEBUG: Workflow validation result: {isValid}");
        if (!isValid)
        {
            var validationError = new InvalidOperationException($"Workflow {workflow.Id} не прошел валидацию");
            Console.WriteLine("DEBUG: Returning failed result due to validation failure");
            return CreateFailedResult(context.ExecutionId, validationError);
        }

        // Инициализация контекста выполнения с переменными и состоянием (вне основного try-catch)
        var initializedContext = InitializeExecutionContext(workflow, context);

        try
        {
            // Построение графа выполнения из шагов workflow
            var executionGraph = BuildExecutionGraph(workflow.Steps);
            _logger.LogDebug("Граф выполнения построен для workflow {WorkflowId} с {StepCount} шагами",
                workflow.Id, workflow.Steps.Count);

            _logger.LogDebug("Контекст выполнения инициализирован для {ExecutionId} с {VariableCount} переменными",
                context.ExecutionId, initializedContext.Variables.Count);

            // Инициализация результата выполнения
            var result = new WorkflowExecutionResult(
                context.ExecutionId,
                WorkflowStatus.Running,
                new Dictionary<string, object>(initializedContext.Variables),
                new List<WorkflowStepResult>()
            );

            // Сохранение результата для отслеживания состояния
            _executionResults[context.ExecutionId] = result;

            _logger.LogInformation("Workflow {WorkflowId} инициализирован и готов к выполнению с {GraphNodeCount} узлами графа",
                workflow.Id, executionGraph.Count);

            // Выполнение шагов с использованием топологической сортировки
            _logger.LogDebug("DEBUG: About to execute steps. Workflow steps count: {StepCount}, Graph nodes: {GraphCount}",
                workflow.Steps.Count, executionGraph.Count);
            var stepResults = await ExecuteStepsAsync(workflow.Steps, executionGraph, initializedContext);
            _logger.LogDebug("DEBUG: ExecuteStepsAsync returned {ResultCount} step results", stepResults.Count);

            // Определение финального статуса на основе результатов шагов
            // Определение финального статуса: только если ВСЕ шаги успешно выполнены или пропущены
            // Блокированные шаги не включаются в stepResults, но пропущенные шаги включаются как Completed
            var hasFailedSteps = stepResults.Any(sr => sr.Status == WorkflowStatus.Failed);
            var hasBlockedSteps = stepResults.Count < workflow.Steps.Count;

            // Workflow успешен если нет failed steps, нет заблокированных steps, и все имеющиеся результаты Completed
            var finalStatus = (!hasFailedSteps && !hasBlockedSteps && stepResults.All(sr => sr.Status == WorkflowStatus.Completed))
                ? WorkflowStatus.Completed
                : WorkflowStatus.Failed;

            // Создание финального результата с обновленными переменными и результатами шагов
            var finalOutputVariables = new Dictionary<string, object>(result.OutputVariables);

            // Объединение выходных переменных из всех шагов
            foreach (var stepResult in stepResults)
            {
                if (stepResult.Output != null)
                {
                    foreach (var output in stepResult.Output)
                    {
                        finalOutputVariables[$"{stepResult.StepId}.{output.Key}"] = output.Value;
                    }
                }
            }

            return result with
            {
                Status = finalStatus,
                OutputVariables = finalOutputVariables,
                StepResults = stepResults
            };
        }
        catch (Exception ex)
        {
            Console.WriteLine($"DEBUG: Exception in ExecuteAsync: {ex.Message}");
            Console.WriteLine($"DEBUG: Exception type: {ex.GetType().Name}");
            Console.WriteLine($"DEBUG: Stack trace: {ex.StackTrace}");
            _logger.LogError(ex, "Ошибка при выполнении workflow {WorkflowId}", workflow.Id);
            return CreateFailedResult(context.ExecutionId, ex);
        }
    }

    /// <summary>
    /// Валидирует структуру и корректность workflow перед выполнением
    /// </summary>
    /// <param name="workflow">Workflow для валидации</param>
    /// <returns>True если workflow корректен, false в противном случае</returns>
    public async Task<bool> ValidateWorkflowAsync(WorkflowDefinition workflow)
    {
        if (workflow == null)
        {
            _logger.LogWarning("Попытка валидации null workflow");
            return false;
        }

        try
        {
            // Базовая валидация структуры
            if (string.IsNullOrWhiteSpace(workflow.Id))
            {
                _logger.LogWarning("Workflow имеет пустой ID");
                return false;
            }

            if (string.IsNullOrWhiteSpace(workflow.Name))
            {
                _logger.LogWarning("Workflow {WorkflowId} имеет пустое название", workflow.Id);
                return false;
            }

            if (workflow.Steps == null || workflow.Steps.Count == 0)
            {
                _logger.LogWarning("Workflow {WorkflowId} не содержит шагов", workflow.Id);
                return false;
            }

            // Валидация уникальности ID шагов
            var stepIds = workflow.Steps.Select(s => s.Id).ToList();
            if (stepIds.Count != stepIds.Distinct().Count())
            {
                _logger.LogWarning("Workflow {WorkflowId} содержит дублирующиеся ID шагов", workflow.Id);
                return false;
            }

            // Валидация зависимостей шагов
            var stepsWithMissingDeps = new List<string>();
            var totalStepsWithDeps = 0;

            foreach (var step in workflow.Steps)
            {
                if (step.DependsOn != null && step.DependsOn.Count > 0)
                {
                    totalStepsWithDeps++;
                    foreach (var dependency in step.DependsOn)
                    {
                        if (!stepIds.Contains(dependency))
                        {
                            _logger.LogWarning("Шаг {StepId} в workflow {WorkflowId} зависит от несуществующего шага {DependencyId}",
                                step.Id, workflow.Id, dependency);
                            if (!stepsWithMissingDeps.Contains(step.Id))
                            {
                                stepsWithMissingDeps.Add(step.Id);
                            }
                        }
                    }
                }
            }

            // Если ВСЕ шаги имеют невалидные зависимости, то workflow невалиден
            // Если есть хотя бы один исполнимый шаг (без зависимостей или с валидными зависимостями), то workflow валиден
            var independentSteps = workflow.Steps.Count(s => s.DependsOn == null || s.DependsOn.Count == 0);
            var stepsWithValidDeps = totalStepsWithDeps - stepsWithMissingDeps.Count;
            var executableSteps = independentSteps + stepsWithValidDeps;

            if (executableSteps == 0)
            {
                _logger.LogWarning("Workflow {WorkflowId} не содержит исполнимых шагов - все шаги имеют невалидные зависимости", workflow.Id);
                return false;
            }

            if (stepsWithMissingDeps.Count > 0)
            {
                _logger.LogInformation("Workflow {WorkflowId} содержит {InvalidCount} шагов с отсутствующими зависимостями из {TotalSteps} общего количества - они будут заблокированы во время выполнения",
                    workflow.Id, stepsWithMissingDeps.Count, workflow.Steps.Count);
            }

            // Попытка построения графа для проверки циклических зависимостей
            try
            {
                BuildExecutionGraph(workflow.Steps);
            }
            catch (InvalidOperationException ex)
            {
                _logger.LogWarning("Workflow {WorkflowId} содержит циклические зависимости: {Error}",
                    workflow.Id, ex.Message);
                return false;
            }

            _logger.LogDebug("Workflow {WorkflowId} прошел полную валидацию", workflow.Id);
            return true;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Ошибка при валидации workflow {WorkflowId}", workflow?.Id ?? "unknown");
            return false;
        }
    }

    /// <summary>
    /// Приостанавливает выполнение запущенного workflow
    /// </summary>
    /// <param name="executionId">Идентификатор выполнения для приостановки</param>
    public async Task PauseExecutionAsync(string executionId)
    {
        if (string.IsNullOrWhiteSpace(executionId))
        {
            throw new ArgumentException("Execution ID не может быть пустым", nameof(executionId));
        }

        if (_executionResults.TryGetValue(executionId, out var result))
        {
            var previousStatus = result.Status;

            // Валидация возможности перехода в состояние Paused
            if (IsValidStateTransition(result.Status, WorkflowStatus.Paused))
            {
                // Обновление контекста выполнения с временной меткой приостановки
                var updatedVariables = new Dictionary<string, object>(result.OutputVariables)
                {
                    ["_pausedAt"] = DateTime.UtcNow,
                    ["_previousStatus"] = previousStatus.ToString()
                };

                var updatedResult = result with
                {
                    Status = WorkflowStatus.Paused,
                    OutputVariables = updatedVariables
                };

                _executionResults[executionId] = updatedResult;

                _logger.LogInformation("Выполнение {ExecutionId} приостановлено (переход {FromStatus} -> {ToStatus}) в {Timestamp}",
                    executionId, previousStatus, WorkflowStatus.Paused, DateTime.UtcNow);
            }
            else
            {
                _logger.LogWarning("Невозможно приостановить выполнение {ExecutionId} в статусе {Status}. Допустимые переходы: {ValidTransitions}",
                    executionId, result.Status, GetValidTransitions(result.Status));
                throw new InvalidOperationException($"Невозможно приостановить workflow в статусе {result.Status}");
            }
        }
        else
        {
            _logger.LogWarning("Выполнение {ExecutionId} не найдено для приостановки", executionId);
            throw new InvalidOperationException($"Выполнение с ID '{executionId}' не найдено");
        }

        await Task.CompletedTask;
    }

    /// <summary>
    /// Возобновляет выполнение приостановленного workflow
    /// </summary>
    /// <param name="executionId">Идентификатор выполнения для возобновления</param>
    public async Task ResumeExecutionAsync(string executionId)
    {
        if (string.IsNullOrWhiteSpace(executionId))
        {
            throw new ArgumentException("Execution ID не может быть пустым", nameof(executionId));
        }

        if (_executionResults.TryGetValue(executionId, out var result))
        {
            var previousStatus = result.Status;

            // Валидация возможности перехода в состояние Running
            if (IsValidStateTransition(result.Status, WorkflowStatus.Running))
            {
                // Обновление контекста выполнения с временной меткой возобновления
                var updatedVariables = new Dictionary<string, object>(result.OutputVariables)
                {
                    ["_resumedAt"] = DateTime.UtcNow
                };

                // Удаление переменных паузы, если они существуют
                updatedVariables.Remove("_pausedAt");
                updatedVariables.Remove("_previousStatus");

                // Вычисление времени паузы, если оно было
                if (result.OutputVariables.TryGetValue("_pausedAt", out var pausedAtObj) && pausedAtObj is DateTime pausedAt)
                {
                    var pauseDuration = DateTime.UtcNow - pausedAt;
                    updatedVariables["_totalPauseDuration"] = pauseDuration.TotalMilliseconds;
                    _logger.LogDebug("Выполнение {ExecutionId} было приостановлено на {PauseDuration} мс",
                        executionId, pauseDuration.TotalMilliseconds);
                }

                var updatedResult = result with
                {
                    Status = WorkflowStatus.Running,
                    OutputVariables = updatedVariables
                };

                _executionResults[executionId] = updatedResult;

                _logger.LogInformation("Выполнение {ExecutionId} возобновлено (переход {FromStatus} -> {ToStatus}) в {Timestamp}",
                    executionId, previousStatus, WorkflowStatus.Running, DateTime.UtcNow);
            }
            else
            {
                _logger.LogWarning("Невозможно возобновить выполнение {ExecutionId} в статусе {Status}. Допустимые переходы: {ValidTransitions}",
                    executionId, result.Status, GetValidTransitions(result.Status));
                throw new InvalidOperationException($"Невозможно возобновить workflow в статусе {result.Status}");
            }
        }
        else
        {
            _logger.LogWarning("Выполнение {ExecutionId} не найдено для возобновления", executionId);
            throw new InvalidOperationException($"Выполнение с ID '{executionId}' не найдено");
        }

        await Task.CompletedTask;
    }

    /// <summary>
    /// Валидация возможности перехода между состояниями workflow
    /// </summary>
    /// <param name="fromStatus">Текущий статус</param>
    /// <param name="toStatus">Целевой статус</param>
    /// <returns>True если переход возможен</returns>
    private static bool IsValidStateTransition(WorkflowStatus fromStatus, WorkflowStatus toStatus)
    {
        return fromStatus switch
        {
            WorkflowStatus.Pending => toStatus is WorkflowStatus.Running or WorkflowStatus.Failed,
            WorkflowStatus.Running => toStatus is WorkflowStatus.Paused or WorkflowStatus.Completed or WorkflowStatus.Failed,
            WorkflowStatus.Paused => toStatus is WorkflowStatus.Running or WorkflowStatus.Failed,
            WorkflowStatus.Completed => false, // Завершенный workflow нельзя изменить
            WorkflowStatus.Failed => false, // Неудачный workflow нельзя изменить
            _ => false
        };
    }

    /// <summary>
    /// Получает список допустимых переходов из текущего состояния
    /// </summary>
    /// <param name="currentStatus">Текущий статус workflow</param>
    /// <returns>Строка с допустимыми переходами</returns>
    private static string GetValidTransitions(WorkflowStatus currentStatus)
    {
        var validTransitions = currentStatus switch
        {
            WorkflowStatus.Pending => "Running, Failed",
            WorkflowStatus.Running => "Paused, Completed, Failed",
            WorkflowStatus.Paused => "Running, Failed",
            WorkflowStatus.Completed => "None",
            WorkflowStatus.Failed => "None",
            _ => "Unknown"
        };

        return validTransitions;
    }

    /// <summary>
    /// Получает текущий статус выполнения workflow
    /// </summary>
    /// <param name="executionId">Идентификатор выполнения</param>
    /// <returns>Результат выполнения или null если не найден</returns>
    public WorkflowExecutionResult? GetExecutionStatus(string executionId)
    {
        if (string.IsNullOrWhiteSpace(executionId))
        {
            throw new ArgumentException("Execution ID не может быть пустым", nameof(executionId));
        }

        _executionResults.TryGetValue(executionId, out var result);
        return result;
    }

    /// <summary>
    /// Получает список всех активных выполнений (не в состоянии Completed или Failed)
    /// </summary>
    /// <returns>Список активных выполнений</returns>
    public IEnumerable<WorkflowExecutionResult> GetActiveExecutions()
    {
        return _executionResults.Values
            .Where(result => result.Status is WorkflowStatus.Pending or WorkflowStatus.Running or WorkflowStatus.Paused)
            .ToList();
    }

    /// <summary>
    /// Проверяет, можно ли выполнить переход состояния для указанного выполнения
    /// </summary>
    /// <param name="executionId">Идентификатор выполнения</param>
    /// <param name="targetStatus">Целевое состояние</param>
    /// <returns>True если переход возможен</returns>
    public bool CanTransitionTo(string executionId, WorkflowStatus targetStatus)
    {
        if (string.IsNullOrWhiteSpace(executionId))
        {
            return false;
        }

        if (_executionResults.TryGetValue(executionId, out var result))
        {
            return IsValidStateTransition(result.Status, targetStatus);
        }

        return false;
    }

    /// <summary>
    /// Построение графа выполнения из шагов workflow
    /// </summary>
    /// <param name="steps">Список шагов workflow</param>
    /// <returns>Граф выполнения в виде словаря зависимостей</returns>
    private Dictionary<string, List<string>> BuildExecutionGraph(List<WorkflowStep> steps)
    {
        var executionGraph = new Dictionary<string, List<string>>();
        var stepIds = steps.Select(s => s.Id).ToHashSet();

        foreach (var step in steps)
        {
            // Инициализация узла графа
            if (!executionGraph.ContainsKey(step.Id))
            {
                executionGraph[step.Id] = new List<string>();
            }

            // Добавление зависимостей только для существующих шагов
            if (step.DependsOn != null && step.DependsOn.Count > 0)
            {
                foreach (var dependency in step.DependsOn)
                {
                    // Пропускаем несуществующие зависимости - они будут обработаны во время выполнения
                    if (stepIds.Contains(dependency))
                    {
                        if (!executionGraph.ContainsKey(dependency))
                        {
                            executionGraph[dependency] = new List<string>();
                        }

                        // Добавляем связь: dependency -> step.Id
                        if (!executionGraph[dependency].Contains(step.Id))
                        {
                            executionGraph[dependency].Add(step.Id);
                        }
                    }
                    else
                    {
                        _logger.LogDebug("Пропуск несуществующей зависимости {Dependency} для шага {StepId}",
                            dependency, step.Id);
                    }
                }
            }
        }

        // Валидация графа на циклические зависимости только для существующих шагов
        ValidateExecutionGraphForCycles(executionGraph, stepIds.ToList());

        _logger.LogDebug("Граф выполнения построен: {GraphStructure}",
            string.Join(", ", executionGraph.Select(kvp => $"{kvp.Key}->[{string.Join(",", kvp.Value)}]")));

        return executionGraph;
    }

    /// <summary>
    /// Инициализация контекста выполнения с переменными workflow и пользовательскими значениями
    /// </summary>
    /// <param name="workflow">Определение workflow</param>
    /// <param name="context">Пользовательский контекст</param>
    /// <returns>Инициализированный контекст выполнения</returns>
    private WorkflowContext InitializeExecutionContext(WorkflowDefinition workflow, WorkflowContext context)
    {
        var mergedVariables = new Dictionary<string, object>(context.Variables ?? new Dictionary<string, object>());

        // Инициализация переменных из определения workflow
        if (workflow.Variables != null)
        {
            foreach (var variableDefinition in workflow.Variables)
            {
                var variableName = variableDefinition.Key;
                var definition = variableDefinition.Value;

                // Если переменная не задана в контексте, используем значение по умолчанию
                if (!mergedVariables.ContainsKey(variableName))
                {
                    if (definition.DefaultValue != null)
                    {
                        mergedVariables[variableName] = definition.DefaultValue;
                        _logger.LogDebug("Инициализирована переменная {VariableName} значением по умолчанию {DefaultValue}",
                            variableName, definition.DefaultValue);
                    }
                    else if (definition.IsRequired)
                    {
                        throw new InvalidOperationException(
                            $"Обязательная переменная '{variableName}' не задана в контексте и не имеет значения по умолчанию");
                    }
                }
                else
                {
                    // Валидация типа переменной (временно отключена для совместимости с строковыми типами)
                    // TODO: Реализовать валидацию типов для строковых определений типов
                    // var actualType = mergedVariables[variableName]?.GetType();
                    // if (actualType != null && !IsTypeCompatible(actualType, definition.Type))
                    // {
                    //     _logger.LogWarning("Переменная {VariableName} имеет тип {ActualType}, ожидался {ExpectedType}",
                    //         variableName, actualType.Name, definition.Type);
                    // }
                }
            }
        }

        // Добавление системных переменных
        mergedVariables["_executionId"] = context.ExecutionId;
        mergedVariables["_workflowId"] = workflow.Id;
        mergedVariables["_startTime"] = DateTime.UtcNow;

        return new WorkflowContext(mergedVariables, context.ExecutionId, context.CancellationToken);
    }

    /// <summary>
    /// Валидация графа выполнения на отсутствие циклических зависимостей
    /// </summary>
    /// <param name="graph">Граф выполнения</param>
    /// <param name="allStepIds">Все идентификаторы шагов</param>
    private void ValidateExecutionGraphForCycles(Dictionary<string, List<string>> graph, List<string> allStepIds)
    {
        var visited = new HashSet<string>();
        var recursionStack = new HashSet<string>();

        foreach (var stepId in allStepIds)
        {
            if (!visited.Contains(stepId))
            {
                if (HasCycleDFS(stepId, graph, visited, recursionStack))
                {
                    throw new InvalidOperationException($"Обнаружена циклическая зависимость в графе выполнения, начинающаяся с шага '{stepId}'");
                }
            }
        }
    }

    /// <summary>
    /// Поиск циклов в графе с использованием DFS
    /// </summary>
    /// <param name="stepId">Текущий шаг</param>
    /// <param name="graph">Граф выполнения</param>
    /// <param name="visited">Посещенные узлы</param>
    /// <param name="recursionStack">Стек рекурсии</param>
    /// <returns>True если найден цикл</returns>
    private bool HasCycleDFS(string stepId, Dictionary<string, List<string>> graph, HashSet<string> visited, HashSet<string> recursionStack)
    {
        visited.Add(stepId);
        recursionStack.Add(stepId);

        if (graph.ContainsKey(stepId))
        {
            foreach (var dependency in graph[stepId])
            {
                if (!visited.Contains(dependency))
                {
                    if (HasCycleDFS(dependency, graph, visited, recursionStack))
                    {
                        return true;
                    }
                }
                else if (recursionStack.Contains(dependency))
                {
                    return true;
                }
            }
        }

        recursionStack.Remove(stepId);
        return false;
    }

    /// <summary>
    /// Выполняет шаги workflow в правильном порядке зависимостей с использованием топологической сортировки
    /// </summary>
    /// <param name="steps">Список шагов workflow</param>
    /// <param name="executionGraph">Граф зависимостей шагов</param>
    /// <param name="context">Контекст выполнения с переменными</param>
    /// <returns>Список результатов выполнения шагов</returns>
    private async Task<List<WorkflowStepResult>> ExecuteStepsAsync(
        List<WorkflowStep> steps,
        Dictionary<string, List<string>> executionGraph,
        WorkflowContext context)
    {
        var stepResults = new List<WorkflowStepResult>();
        var completedSteps = new HashSet<string>();
        var failedSteps = new HashSet<string>();
        var blockedSteps = new HashSet<string>();
        var stepLookup = steps.ToDictionary(s => s.Id, s => s);
        var stepResultLookup = new Dictionary<string, WorkflowStepResult>();

        // Топологическая сортировка для определения порядка выполнения
        var executionOrder = TopologicalSort(steps, executionGraph);

        _logger.LogDebug("Порядок выполнения шагов: {ExecutionOrder}", string.Join(" -> ", executionOrder));
        _logger.LogDebug("DEBUG: Execution order contains {OrderCount} steps for {StepCount} total steps",
            executionOrder.Count, steps.Count);

        // Выполнение шагов в топологическом порядке - обеспечиваем выполнение независимых шагов
        foreach (var stepId in executionOrder)
        {
            if (!stepLookup.ContainsKey(stepId))
            {
                _logger.LogWarning("Шаг {StepId} не найден в списке шагов", stepId);
                continue;
            }

            var step = stepLookup[stepId];

            try
            {
                // Проверка зависимостей перед выполнением шага
                var dependencyCheckResult = ValidateDependencies(step, completedSteps, failedSteps, stepResultLookup);
                if (!dependencyCheckResult.CanExecute)
                {
                    // Различаем типы блокировки:
                    // - Отсутствующие зависимости (должны появиться в результатах как Failed)
                    // - Неудачные зависимости (НЕ должны появиться в результатах)
                    var blockingReason = dependencyCheckResult.BlockingReason ?? "";
                    
                    if (blockingReason.Contains("отсутствуют зависимости") || blockingReason.Contains("Отсутствующие зависимости"))
                    {
                        // Шаг заблокирован из-за отсутствующих зависимостей - создаем Failed результат
                        var blockedResult = CreateBlockedStepResult(
                            stepId,
                            dependencyCheckResult.BlockingReason,
                            dependencyCheckResult.FailedDependencies);

                        stepResults.Add(blockedResult);
                        stepResultLookup[stepId] = blockedResult;
                        blockedSteps.Add(stepId);
                        failedSteps.Add(stepId);

                        _logger.LogWarning("Шаг {StepId} заблокирован и добавлен как Failed: {Reason}", stepId, dependencyCheckResult.BlockingReason);
                    }
                    else
                    {
                        // Шаг заблокирован из-за неудачных зависимостей - НЕ добавляем в результаты
                        blockedSteps.Add(stepId);
                        failedSteps.Add(stepId);

                        _logger.LogWarning("Шаг {StepId} заблокирован и пропущен: {Reason}", stepId, dependencyCheckResult.BlockingReason);
                    }

                    // Пропускаем выполнение заблокированного шага
                    continue;
                }
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Ошибка при проверке зависимостей для шага {StepId}", stepId);
                continue;
            }

            // Выполнение отдельного шага
            var executionResult = await ExecuteSingleStepAsync(step, context, stepResults);
            stepResults.Add(executionResult);
            stepResultLookup[stepId] = executionResult;

            if (executionResult.Status == WorkflowStatus.Completed)
            {
                completedSteps.Add(stepId);
                _logger.LogDebug("Шаг {StepId} выполнен успешно", stepId);

                // Обновление контекста выполнения переменными из результата шага
                UpdateContextWithStepOutput(stepId, executionResult, context);
            }
            else
            {
                failedSteps.Add(stepId);
                _logger.LogError("Шаг {StepId} завершен с ошибкой: {Status}", stepId, executionResult.Status);

                // Распространяем ошибку на зависимые шаги
                PropagateFailureToDescendants(stepId, executionGraph, failedSteps, blockedSteps, stepResults, stepResultLookup);

                // Добавляем информацию об ошибке в контекст для отладки
                context.Variables[$"_error_{stepId}"] = executionResult.Error?.Message ?? "Unknown error";
                context.Variables[$"_failed_steps"] = string.Join(",", failedSteps);
            }
        }

        _logger.LogInformation("Выполнение шагов завершено: {CompletedCount}/{TotalCount} шагов успешно, {FailedCount} с ошибками, {BlockedCount} заблокированы",
            completedSteps.Count, steps.Count, failedSteps.Count, blockedSteps.Count);

        _logger.LogDebug("DEBUG: Returning {StepResultsCount} step results from ExecuteStepsAsync", stepResults.Count);
        return stepResults;
    }

    /// <summary>
    /// Выполняет отдельный шаг workflow с обработкой ошибок и retry logic
    /// </summary>
    /// <param name="step">Шаг для выполнения</param>
    /// <param name="context">Контекст выполнения</param>
    /// <param name="previousResults">Результаты предыдущих шагов</param>
    /// <returns>Результат выполнения шага</returns>
    private async Task<WorkflowStepResult> ExecuteSingleStepAsync(
        WorkflowStep step,
        WorkflowContext context,
        List<WorkflowStepResult> previousResults)
    {
        var totalStopwatch = System.Diagnostics.Stopwatch.StartNew();
        Exception? lastException = null;
        Dictionary<string, object>? lastOutput = null;
        var attemptCount = 0;
        var maxAttempts = (step.RetryPolicy?.MaxRetryCount ?? 0) + 1; // +1 for initial attempt

        _logger.LogDebug("Начало выполнения шага {StepId} типа {StepType} с максимальным количеством попыток: {MaxAttempts}",
            step.Id, step.Type, maxAttempts);

        // Проверка условий выполнения шага (если заданы) - выполняется только один раз
        if (step.Condition != null && !await EvaluateConditionAsync(step.Condition, context))
        {
            _logger.LogDebug("Шаг {StepId} пропущен из-за невыполнения условия: {Condition}",
                step.Id, step.Condition.Expression);

            totalStopwatch.Stop();
            return new WorkflowStepResult(
                step.Id,
                WorkflowStatus.Completed,
                new Dictionary<string, object>
                {
                    ["skipped"] = true,
                    ["reason"] = "condition_not_met",
                    ["totalAttempts"] = 0
                },
                null,
                totalStopwatch.Elapsed
            );
        }

        // Основной цикл выполнения с повторными попытками
        while (attemptCount < maxAttempts)
        {
            attemptCount++;
            // Проверяем отмену перед попыткой
            context.CancellationToken.ThrowIfCancellationRequested();
            var attemptStopwatch = System.Diagnostics.Stopwatch.StartNew();

            try
            {
                _logger.LogDebug("Попытка {AttemptNumber}/{MaxAttempts} выполнения шага {StepId}",
                    attemptCount, maxAttempts, step.Id);

                // Выполнение шага в зависимости от его типа
                lastOutput = await ExecuteStepByTypeAsync(step, context, previousResults);

                attemptStopwatch.Stop();
                totalStopwatch.Stop();

                _logger.LogDebug("Шаг {StepId} успешно выполнен с попытки {AttemptNumber}", step.Id, attemptCount);

                // Добавляем информацию о retry в выходные данные
                lastOutput["totalAttempts"] = attemptCount;
                if (attemptCount > 1)
                {
                    lastOutput["retriesUsed"] = attemptCount - 1;
                    lastOutput["totalRetryTime"] = totalStopwatch.Elapsed.TotalMilliseconds;
                }

                return new WorkflowStepResult(
                    step.Id,
                    WorkflowStatus.Completed,
                    lastOutput,
                    null,
                    totalStopwatch.Elapsed
                );
            }
            catch (Exception ex)
            {
                attemptStopwatch.Stop();
                lastException = ex;

                _logger.LogWarning(ex, "Попытка {AttemptNumber}/{MaxAttempts} выполнения шага {StepId} неудачна: {ErrorMessage}",
                    attemptCount, maxAttempts, step.Id, ex.Message);

                // Если это не последняя попытка и есть политика повторов
                if (attemptCount < maxAttempts && step.RetryPolicy != null)
                {
                    var delay = CalculateRetryDelay(step.RetryPolicy, attemptCount - 1);
                    _logger.LogDebug("Ожидание {DelayMs} мс перед следующей попыткой шага {StepId}",
                        delay.TotalMilliseconds, step.Id);

                    await Task.Delay(delay, context.CancellationToken);
                }
            }
        }

        // Все попытки исчерпаны
        totalStopwatch.Stop();

        _logger.LogError(lastException, "Все попытки ({TotalAttempts}) выполнения шага {StepId} исчерпаны",
            attemptCount, step.Id);

        // Создаем выходные данные с информацией о неудачных попытках
        var failureOutput = new Dictionary<string, object>
        {
            ["totalAttempts"] = attemptCount,
            ["allAttemptsFailed"] = true,
            ["totalRetryTime"] = totalStopwatch.Elapsed.TotalMilliseconds
        };

        return new WorkflowStepResult(
            step.Id,
            WorkflowStatus.Failed,
            failureOutput,
            lastException,
            totalStopwatch.Elapsed
        );
    }

    /// <summary>
    /// Вычисляет задержку для повторной попытки на основе политики retry
    /// </summary>
    /// <param name="retryPolicy">Политика повторных попыток</param>
    /// <param name="retryAttempt">Номер попытки повтора (начиная с 0)</param>
    /// <returns>Время задержки перед следующей попыткой</returns>
    private TimeSpan CalculateRetryDelay(RetryPolicy retryPolicy, int retryAttempt)
    {
        // Экспоненциальная задержка: BaseDelay * (BackoffMultiplier ^ retryAttempt)
        var delay = TimeSpan.FromMilliseconds(
            retryPolicy.EffectiveBaseDelay.TotalMilliseconds *
            Math.Pow(retryPolicy.BackoffMultiplier, retryAttempt)
        );

        // Ограничиваем максимальной задержкой
        if (delay > retryPolicy.EffectiveMaxDelay)
        {
            delay = retryPolicy.EffectiveMaxDelay;
        }

        return delay;
    }

    /// <summary>
    /// Выполняет шаг в зависимости от его типа
    /// </summary>
    /// <param name="step">Шаг для выполнения</param>
    /// <param name="context">Контекст выполнения</param>
    /// <param name="previousResults">Результаты предыдущих шагов</param>
    /// <returns>Выходные данные шага</returns>
    private async Task<Dictionary<string, object>> ExecuteStepByTypeAsync(
        WorkflowStep step,
        WorkflowContext context,
        List<WorkflowStepResult> previousResults)
    {
        var output = new Dictionary<string, object>();

        switch (step.Type)
        {
            case WorkflowStepType.Task:
                // Выполнение обычной задачи

                // Специальная обработка для тестирования ошибок
                if (step.Command.StartsWith("fail"))
                {
                    // Команды для тестирования:
                    // "fail" - всегда кидает исключение
                    // "fail-intermittent" - случайно кидает исключение
                    // "fail-first-N" где N - количество первых попыток, которые должны упасть

                    if (step.Command == "fail")
                    {
                        throw new InvalidOperationException($"Тестовая ошибка в шаге {step.Id}");
                    }
                    else if (step.Command == "fail-intermittent")
                    {
                        var random = new Random();
                        if (random.Next(0, 2) == 0) // 50% вероятность ошибки
                        {
                            throw new InvalidOperationException($"Прерывистая ошибка в шаге {step.Id}");
                        }
                    }
                    else if (step.Command.StartsWith("fail-first-"))
                    {
                        // Извлекаем количество попыток, которые должны упасть
                        var failCountStr = step.Command.Substring("fail-first-".Length);
                        if (int.TryParse(failCountStr, out var failCount))
                        {
                            // Проверяем текущую попытку из параметров (если есть)
                            var currentAttempt = 1; // По умолчанию первая попытка
                            if (step.Parameters.TryGetValue("_currentAttempt", out var attemptObj) && attemptObj is int attempt)
                            {
                                currentAttempt = attempt;
                            }

                            if (currentAttempt <= failCount)
                            {
                                throw new InvalidOperationException($"Запланированная ошибка в шаге {step.Id} на попытке {currentAttempt}");
                            }
                        }
                    }
                }

                output["result"] = $"Выполнена команда: {step.Command}";
                output["parameters"] = step.Parameters;
                output["executedAt"] = DateTime.UtcNow;
                break;

            case WorkflowStepType.Start:
                // Начальный шаг - просто логирование
                output["startTime"] = DateTime.UtcNow;
                output["workflowStarted"] = true;
                break;

            case WorkflowStepType.End:
                // Завершающий шаг - сбор итоговых данных
                output["endTime"] = DateTime.UtcNow;
                output["totalStepsExecuted"] = previousResults.Count;
                output["workflowCompleted"] = true;
                break;

            case WorkflowStepType.Condition:
                // Условный шаг - оценка логики
                if (step.Condition != null)
                {
                    var conditionResult = await EvaluateConditionAsync(step.Condition, context);
                    output["conditionResult"] = conditionResult;
                    output["conditionExpression"] = step.Condition.Expression;
                }
                break;

            case WorkflowStepType.Loop:
                // Выполнение цикла
                if (step.LoopDefinition == null)
                {
                    throw new InvalidOperationException($"Шаг типа Loop {step.Id} должен содержать определение цикла");
                }

                if (step.NestedSteps == null || step.NestedSteps.Count == 0)
                {
                    _logger.LogWarning("Шаг типа Loop {StepId} не содержит вложенных шагов", step.Id);
                    output["loopResult"] = "empty";
                    output["message"] = "No nested steps to execute";
                    break;
                }

                // Выполнение цикла с помощью LoopExecutor
                var loopResult = await _loopExecutor.ExecuteLoopAsync(
                    step.LoopDefinition,
                    step.NestedSteps,
                    context,
                    ExecuteNestedStepsAsync);

                // Преобразование результата цикла в выходные данные шага
                output["loopType"] = loopResult.LoopType.ToString();
                output["loopStatus"] = loopResult.Status.ToString();
                output["totalIterations"] = loopResult.TotalIterations;
                output["successfulIterations"] = loopResult.SuccessfulIterations;
                output["failedIterations"] = loopResult.FailedIterations;
                output["duration"] = loopResult.Duration.TotalMilliseconds;

                // Добавление выходных переменных цикла
                foreach (var variable in loopResult.OutputVariables)
                {
                    output[$"loop_{variable.Key}"] = variable.Value;
                }

                // Если цикл завершился с ошибкой, пробрасываем исключение
                if (loopResult.Status == LoopExecutionStatus.Failed && loopResult.Error != null)
                {
                    throw loopResult.Error;
                }

                break;

            case WorkflowStepType.Parallel:
                // Параллельное выполнение - заглушка для будущей реализации
                output["parallelType"] = "placeholder";
                output["message"] = "Parallel execution will be implemented in future tasks";
                break;

            default:
                throw new NotSupportedException($"Тип шага {step.Type} не поддерживается");
        }

        _logger.LogDebug("Шаг {StepId} типа {StepType} выполнен с результатом: {OutputKeys}",
            step.Id, step.Type, string.Join(", ", output.Keys));

        return output;
    }

    /// <summary>
    /// Выполняет топологическую сортировку шагов для определения правильного порядка выполнения
    /// </summary>
    /// <param name="steps">Список шагов</param>
    /// <param name="executionGraph">Граф зависимостей</param>
    /// <returns>Список ID шагов в порядке выполнения</returns>
    private List<string> TopologicalSort(List<WorkflowStep> steps, Dictionary<string, List<string>> executionGraph)
    {
        var sorted = new List<string>();
        var visited = new HashSet<string>();
        var visiting = new HashSet<string>();

        // Более простая реализация топологической сортировки с использованием in-degree
        var inDegree = new Dictionary<string, int>();
        var adjList = new Dictionary<string, List<string>>();

        // Инициализация структур данных
        foreach (var step in steps)
        {
            inDegree[step.Id] = 0;
            adjList[step.Id] = new List<string>();
        }

        // Построение графа и подсчет входящих степеней (с валидацией зависимостей)
        var stepIds = steps.Select(s => s.Id).ToHashSet();
        foreach (var step in steps)
        {
            if (step.DependsOn != null)
            {
                foreach (var dependency in step.DependsOn)
                {
                    // Только добавляем зависимости для существующих шагов
                    if (stepIds.Contains(dependency))
                    {
                        adjList[dependency].Add(step.Id);
                        inDegree[step.Id]++;
                    }
                    else
                    {
                        _logger.LogDebug("Пропуск несуществующей зависимости {Dependency} для шага {StepId} в топологической сортировке",
                            dependency, step.Id);
                    }
                }
            }
        }

        // Алгоритм Кана для топологической сортировки
        var queue = new Queue<string>();
        foreach (var kvp in inDegree)
        {
            if (kvp.Value == 0)
            {
                queue.Enqueue(kvp.Key);
            }
        }

        while (queue.Count > 0)
        {
            var current = queue.Dequeue();
            sorted.Add(current);

            foreach (var neighbor in adjList[current])
            {
                inDegree[neighbor]--;
                if (inDegree[neighbor] == 0)
                {
                    queue.Enqueue(neighbor);
                }
            }
        }

        // Проверка на циклические зависимости
        if (sorted.Count != steps.Count)
        {
            throw new InvalidOperationException("Обнаружена циклическая зависимость в workflow");
        }

        return sorted;
    }


    /// <summary>
    /// Оценивает условное выражение в контексте workflow
    /// </summary>
    /// <param name="condition">Условие для оценки</param>
    /// <param name="context">Контекст выполнения</param>
    /// <returns>Результат оценки условия</returns>
    private async Task<bool> EvaluateConditionAsync(ConditionalLogic condition, WorkflowContext context)
    {
        // Простая реализация оценки условий - будет расширена в задаче 3A.3.1
        if (string.IsNullOrWhiteSpace(condition.Expression))
        {
            return true;
        }

        try
        {
            // Поддержка boolean литералов
            var trimmedExpression = condition.Expression.Trim().ToLowerInvariant();
            if (trimmedExpression == "true")
            {
                return true;
            }
            if (trimmedExpression == "false")
            {
                return false;
            }

            // Базовая поддержка простых сравнений
            if (condition.Expression.Contains("=="))
            {
                var parts = condition.Expression.Split("==", StringSplitOptions.TrimEntries);
                if (parts.Length == 2)
                {
                    var leftValue = ResolveVariableValue(parts[0], context);
                    var rightValue = parts[1].Trim('"', '\'');
                    return string.Equals(leftValue?.ToString(), rightValue, StringComparison.OrdinalIgnoreCase);
                }
            }

            // Если выражение не распознано, считаем его истинным для совместимости
            _logger.LogWarning("Неизвестное выражение условия: {Expression}. Считается истинным.", condition.Expression);
            return true;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Ошибка при оценке условия: {Expression}", condition.Expression);
            return false;
        }
    }

    /// <summary>
    /// Разрешает значение переменной из контекста
    /// </summary>
    /// <param name="variableReference">Ссылка на переменную (например, $variable или variable)</param>
    /// <param name="context">Контекст выполнения</param>
    /// <returns>Значение переменной или null если не найдена</returns>
    private object? ResolveVariableValue(string variableReference, WorkflowContext context)
    {
        var variableName = variableReference.Trim().TrimStart('$');

        if (context.Variables.TryGetValue(variableName, out var value))
        {
            return value;
        }

        _logger.LogDebug("Переменная {VariableName} не найдена в контексте", variableName);
        return null;
    }

    /// <summary>
    /// Создает результат с ошибкой выполнения
    /// </summary>
    /// <param name="executionId">Идентификатор выполнения</param>
    /// <param name="error">Ошибка выполнения</param>
    /// <returns>Результат выполнения с ошибкой</returns>
    private static WorkflowExecutionResult CreateFailedResult(string executionId, Exception error)
    {
        return new WorkflowExecutionResult(
            executionId,
            WorkflowStatus.Failed,
            new Dictionary<string, object>(),
            new List<WorkflowStepResult>(),
            error
        );
    }

    /// <summary>
    /// Валидирует зависимости шага и определяет возможность его выполнения
    /// </summary>
    /// <param name="step">Шаг для проверки</param>
    /// <param name="completedSteps">Множество успешно выполненных шагов</param>
    /// <param name="failedSteps">Множество неудачно выполненных шагов</param>
    /// <param name="stepResultLookup">Словарь результатов выполнения шагов</param>
    /// <returns>Результат валидации зависимостей</returns>
    private DependencyValidationResult ValidateDependencies(
        WorkflowStep step,
        HashSet<string> completedSteps,
        HashSet<string> failedSteps,
        Dictionary<string, WorkflowStepResult> stepResultLookup)
    {
        if (step.DependsOn == null || step.DependsOn.Count == 0)
        {
            return new DependencyValidationResult(true, null, null);
        }

        var failedDependencies = new List<string>();
        var missingDependencies = new List<string>();
        var nonExistentDependencies = new List<string>();

        foreach (var dependency in step.DependsOn)
        {
            if (failedSteps.Contains(dependency))
            {
                failedDependencies.Add(dependency);
            }
            else if (!completedSteps.Contains(dependency))
            {
                // Проверяем, есть ли результат для этой зависимости
                if (stepResultLookup.TryGetValue(dependency, out var depResult))
                {
                    if (depResult.Status == WorkflowStatus.Failed)
                    {
                        failedDependencies.Add(dependency);
                    }
                    else if (depResult.Status != WorkflowStatus.Completed)
                    {
                        missingDependencies.Add(dependency);
                    }
                }
                else
                {
                    // Проверим, существует ли этот шаг вообще в определении workflow
                    // Если нет, то это отсутствующая зависимость
                    nonExistentDependencies.Add(dependency);
                }
            }
        }

        if (failedDependencies.Count > 0)
        {
            return new DependencyValidationResult(
                false,
                $"Зависимости завершились с ошибкой: {string.Join(", ", failedDependencies)}",
                failedDependencies);
        }

        if (nonExistentDependencies.Count > 0)
        {
            return new DependencyValidationResult(
                false,
                $"отсутствуют зависимости {string.Join(", ", nonExistentDependencies)}",
                nonExistentDependencies);
        }

        if (missingDependencies.Count > 0)
        {
            return new DependencyValidationResult(
                false,
                $"Отсутствующие зависимости: {string.Join(", ", missingDependencies)}",
                missingDependencies);
        }

        return new DependencyValidationResult(true, null, null);
    }

    /// <summary>
    /// Создает результат для заблокированного шага
    /// </summary>
    /// <param name="stepId">Идентификатор шага</param>
    /// <param name="blockingReason">Причина блокировки</param>
    /// <param name="failedDependencies">Список неудачных зависимостей</param>
    /// <returns>Результат заблокированного шага</returns>
    private WorkflowStepResult CreateBlockedStepResult(string stepId, string? blockingReason, List<string>? failedDependencies)
    {
        var output = new Dictionary<string, object>
        {
            ["blocked"] = true,
            ["reason"] = blockingReason ?? "Dependencies not satisfied",
            ["executedAt"] = DateTime.UtcNow
        };

        if (failedDependencies != null && failedDependencies.Count > 0)
        {
            output["failedDependencies"] = failedDependencies;
        }

        var blockingException = new InvalidOperationException(
            $"Шаг {stepId} заблокирован: {blockingReason}");

        return new WorkflowStepResult(
            stepId,
            WorkflowStatus.Failed,
            output,
            blockingException
        );
    }

    /// <summary>
    /// Распространяет блокировку на зависимые шаги
    /// </summary>
    /// <param name="failedStepId">Идентификатор неудачного шага</param>
    /// <param name="executionGraph">Граф выполнения</param>
    /// <param name="blockedSteps">Множество заблокированных шагов</param>
    /// <param name="stepResults">Список результатов шагов</param>
    /// <param name="stepResultLookup">Словарь результатов шагов</param>
    private void PropagateBlockingToDescendants(
        string failedStepId,
        Dictionary<string, List<string>> executionGraph,
        HashSet<string> blockedSteps,
        List<WorkflowStepResult> stepResults,
        Dictionary<string, WorkflowStepResult> stepResultLookup)
    {
        if (!executionGraph.ContainsKey(failedStepId))
        {
            return;
        }

        var toProcess = new Queue<string>();
        toProcess.Enqueue(failedStepId);
        var processed = new HashSet<string>();

        while (toProcess.Count > 0)
        {
            var currentStepId = toProcess.Dequeue();
            if (processed.Contains(currentStepId))
            {
                continue;
            }

            processed.Add(currentStepId);

            if (executionGraph.TryGetValue(currentStepId, out var dependentSteps))
            {
                foreach (var dependentStep in dependentSteps)
                {
                    if (!blockedSteps.Contains(dependentStep) && !stepResultLookup.ContainsKey(dependentStep))
                    {
                        var blockedResult = CreateBlockedStepResult(
                            dependentStep,
                            $"Зависимость {currentStepId} заблокирована или завершилась с ошибкой",
                            new List<string> { currentStepId });

                        stepResults.Add(blockedResult);
                        stepResultLookup[dependentStep] = blockedResult;
                        blockedSteps.Add(dependentStep);

                        // Рекурсивно обрабатываем потомков
                        toProcess.Enqueue(dependentStep);
                    }
                }
            }
        }
    }

    /// <summary>
    /// Распространяет ошибку на зависимые шаги
    /// </summary>
    /// <param name="failedStepId">Идентификатор неудачного шага</param>
    /// <param name="executionGraph">Граф выполнения</param>
    /// <param name="failedSteps">Множество неудачных шагов</param>
    /// <param name="blockedSteps">Множество заблокированных шагов</param>
    /// <param name="stepResults">Список результатов шагов</param>
    /// <param name="stepResultLookup">Словарь результатов шагов</param>
    private void PropagateFailureToDescendants(
        string failedStepId,
        Dictionary<string, List<string>> executionGraph,
        HashSet<string> failedSteps,
        HashSet<string> blockedSteps,
        List<WorkflowStepResult> stepResults,
        Dictionary<string, WorkflowStepResult> stepResultLookup)
    {
        PropagateBlockingToDescendants(failedStepId, executionGraph, blockedSteps, stepResults, stepResultLookup);
    }

    /// <summary>
    /// Обновляет контекст переменными из результата шага
    /// </summary>
    /// <param name="stepId">Идентификатор шага</param>
    /// <param name="stepResult">Результат выполнения шага</param>
    /// <param name="context">Контекст выполнения</param>
    private void UpdateContextWithStepOutput(string stepId, WorkflowStepResult stepResult, WorkflowContext context)
    {
        if (stepResult.Output != null)
        {
            foreach (var output in stepResult.Output)
            {
                // Безопасное обновление переменных контекста
                try
                {
                    context.Variables[$"{stepId}.{output.Key}"] = output.Value;
                    _logger.LogDebug("Обновлена переменная {VariableName} = {Value}",
                        $"{stepId}.{output.Key}", output.Value);
                }
                catch (Exception ex)
                {
                    _logger.LogWarning(ex, "Ошибка при обновлении переменной {VariableName} из шага {StepId}",
                        output.Key, stepId);
                }
            }
        }

        // Добавляем мета-информацию о выполнении
        context.Variables[$"_step_{stepId}_status"] = stepResult.Status.ToString();
        context.Variables[$"_step_{stepId}_duration"] = stepResult.Duration?.TotalMilliseconds ?? 0;
    }

    /// <summary>
    /// Выполняет вложенные шаги для использования в циклах
    /// </summary>
    /// <param name="steps">Список шагов для выполнения</param>
    /// <param name="context">Контекст выполнения</param>
    /// <returns>Результаты выполнения шагов</returns>
    private async Task<List<WorkflowStepResult>> ExecuteNestedStepsAsync(List<WorkflowStep> steps, WorkflowContext context)
    {
        var stepResults = new List<WorkflowStepResult>();

        foreach (var step in steps)
        {
            try
            {
                // Выполнение отдельного шага без зависимостей (в контексте цикла зависимости не применяются)
                var stepResult = await ExecuteSingleStepAsync(step, context, stepResults);
                stepResults.Add(stepResult);

                // Обновление контекста переменными из результата шага
                if (stepResult.Status == WorkflowStatus.Completed)
                {
                    UpdateContextWithStepOutput(step.Id, stepResult, context);
                }
                else
                {
                    _logger.LogWarning("Вложенный шаг {StepId} завершен с ошибкой в цикле", step.Id);
                    // В циклах продолжаем выполнение даже при ошибках в отдельных шагах
                }
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Ошибка при выполнении вложенного шага {StepId} в цикле", step.Id);

                var failedResult = new WorkflowStepResult(
                    step.Id,
                    WorkflowStatus.Failed,
                    new Dictionary<string, object> { ["error"] = ex.Message },
                    ex
                );

                stepResults.Add(failedResult);
            }
        }

        return stepResults;
    }

    /// <summary>
    /// Результат валидации зависимостей шага
    /// </summary>
    private record DependencyValidationResult(
        bool CanExecute,
        string? BlockingReason,
        List<string>? FailedDependencies);
}